name: Deploy xcited to Production

on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - '.github/TRIGGER_DEPLOY'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npx prisma generate || echo "‚ö†Ô∏è  Prisma generate failed (continuing without DB)"
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL || 'postgresql://user:pass@localhost:5432/xcited' }}

      - name: Build Next.js app
        run: npm run build
        env:
          NODE_ENV: production
          DATABASE_URL: ${{ secrets.DATABASE_URL || 'postgresql://user:pass@localhost:5432/xcited' }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET || 'xcited-temp-secret-key-min-32-chars-long-for-build' }}
          NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL || 'https://xcited.ro' }}

      - name: Create deployment package
        run: |
          rm -rf deploy-package
          mkdir -p deploy-package
          
          # Next.js standalone output (like 1dream)
          if [ -d ".next/standalone" ]; then
            echo "‚úÖ Found standalone build"
            echo "üìÅ Standalone structure:"
            ls -la .next/standalone | head -10
            
            # Copy standalone build
            cp -R .next/standalone/* deploy-package/
            
            # CRITICAL: Copy ALL required .next files (not just static)
            # Next.js standalone needs: static, BUILD_ID, and ALL manifest files
            mkdir -p deploy-package/.next
            
            # Copy static assets (required)
            if [ -d ".next/static" ]; then
              cp -R .next/static deploy-package/.next/static
              echo "   ‚úÖ Copied .next/static"
            fi
            
            # Copy BUILD_ID (required)
            if [ -f ".next/BUILD_ID" ]; then
              cp .next/BUILD_ID deploy-package/.next/BUILD_ID
              echo "   ‚úÖ Copied BUILD_ID"
            fi
            
            # Copy ALL .json manifest files from .next/ (Next.js needs all of them)
            echo "   üìã Copying all manifest files from .next/..."
            find .next -maxdepth 1 -name "*.json" -type f | while read -r file; do
              filename=$(basename "$file")
              cp "$file" "deploy-package/.next/$filename"
              echo "   ‚úÖ Copied $filename"
            done
            
            # Copy server directory if it exists (contains middleware, etc.)
            if [ -d ".next/server" ]; then
              cp -R .next/server deploy-package/.next/server
              echo "   ‚úÖ Copied .next/server"
            fi
            
            # Verify critical files exist
            echo "   üîç Verifying critical files..."
            for file in "BUILD_ID" "routes-manifest.json" "build-manifest.json"; do
              if [ -f "deploy-package/.next/$file" ]; then
                echo "   ‚úÖ Verified: $file"
              else
                echo "   ‚ö†Ô∏è  WARN: Missing $file"
              fi
            done
            
            echo "   ‚úÖ Copied standalone build and all required .next files"
            
            # public/ is optional in Next.js projects
            if [ -d "public" ]; then
              cp -R public deploy-package/public
            fi
          else
            echo "‚ö†Ô∏è  No standalone build, using regular build"
            cp -r .next deploy-package/
            if [ -d "public" ]; then
              cp -r public deploy-package/
            fi
          fi
          
          # Copy necessary files
          if [ -d "prisma" ]; then
            cp -r prisma deploy-package/
          fi
          cp package.json deploy-package/
          cp package-lock.json deploy-package/ 2>/dev/null || true
          cp next.config.ts deploy-package/
          cp tsconfig.json deploy-package/
          
          # Copy Prisma generated client
          if [ -d "node_modules/.prisma" ]; then
            mkdir -p deploy-package/node_modules
            cp -r node_modules/.prisma deploy-package/node_modules/ 2>/dev/null || true
          fi
          
          # Create ecosystem.config.js for PM2 (like 1dream - using echo to avoid YAML issues)
          echo 'module.exports = {' > deploy-package/ecosystem.config.js
          echo '  apps: [{' >> deploy-package/ecosystem.config.js
          echo "    name: 'xcited-web'," >> deploy-package/ecosystem.config.js
          echo "    script: 'server.js'," >> deploy-package/ecosystem.config.js
          echo "    cwd: '/home/xcited/public_html'," >> deploy-package/ecosystem.config.js
          echo '    instances: 2,' >> deploy-package/ecosystem.config.js
          echo "    exec_mode: 'cluster'," >> deploy-package/ecosystem.config.js
          echo "    interpreter: 'node'," >> deploy-package/ecosystem.config.js
          echo '    env: {' >> deploy-package/ecosystem.config.js
          echo "      NODE_ENV: 'production'," >> deploy-package/ecosystem.config.js
          echo '      PORT: 3002' >> deploy-package/ecosystem.config.js
          echo '    },' >> deploy-package/ecosystem.config.js
          echo "    error_file: '/var/log/pm2/xcited-web-error.log'," >> deploy-package/ecosystem.config.js
          echo "    out_file: '/var/log/pm2/xcited-web-out.log'," >> deploy-package/ecosystem.config.js
          echo "    log_date_format: 'YYYY-MM-DD HH:mm:ss Z'," >> deploy-package/ecosystem.config.js
          echo '    merge_logs: true,' >> deploy-package/ecosystem.config.js
          echo '    autorestart: true,' >> deploy-package/ecosystem.config.js
          echo "    max_memory_restart: '1G'" >> deploy-package/ecosystem.config.js
          echo '  }]' >> deploy-package/ecosystem.config.js
          echo '}' >> deploy-package/ecosystem.config.js

      - name: Pre-deploy Ensure directory permissions
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.CWP_HOST }}
          username: ${{ secrets.CWP_USER }}
          password: ${{ secrets.CWP_SSH_KEY }}
          port: ${{ secrets.CWP_PORT || 22 }}
          script: |
            set -e
            TARGET="/home/xcited/public_html"
            OWNER_USER="xcited"
            OWNER_GROUP="xcited"
            
            echo "== Pre-deploy: Ensure directory is ready =="
            
            # Verify user exists
            if ! id -u "${OWNER_USER}" >/dev/null 2>&1; then
              echo "‚ö†Ô∏è  ERROR: user '${OWNER_USER}' does not exist!"
              exit 1
            fi
            
            # Ensure target directory exists and has correct ownership
            mkdir -p "${TARGET}"
            
            # Set ownership BEFORE SCP (critical!)
            echo "üîß Setting ownership BEFORE SCP..."
            if sudo -n true 2>/dev/null; then
              sudo -n chown -R "${OWNER_USER}:${OWNER_GROUP}" "${TARGET}" || true
              sudo -n chmod -R u+rwX "${TARGET}" || true
            else
              chown -R "${OWNER_USER}:${OWNER_GROUP}" "${TARGET}" || true
              chmod -R u+rwX "${TARGET}" || true
            fi
            
            # Verify writable
            if ! ( touch "${TARGET}/.gha_write_test" && rm -f "${TARGET}/.gha_write_test" ); then
              echo "‚ö†Ô∏è  WARN: ${TARGET} is not writable"
              if sudo -n true 2>/dev/null; then
                sudo -n chown -R "${OWNER_USER}:${OWNER_GROUP}" "${TARGET}" || true
                sudo -n chmod -R u+rwX "${TARGET}" || true
              fi
            fi
            
            echo "‚úÖ Directory ready for SCP"

      - name: Deploy to CWP7pro Production
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.CWP_HOST }}
          username: ${{ secrets.CWP_USER }}
          password: ${{ secrets.CWP_SSH_KEY }}
          port: ${{ secrets.CWP_PORT || 22 }}
          source: "deploy-package/*"
          target: "/home/xcited/public_html"
          rm: true

      - name: Post-deploy - Set permissions
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.CWP_HOST }}
          username: ${{ secrets.CWP_USER }}
          password: ${{ secrets.CWP_SSH_KEY }}
          port: ${{ secrets.CWP_PORT || 22 }}
          script: |
            set -e
            TARGET="/home/xcited/public_html"
            OWNER_USER="xcited"
            OWNER_GROUP="xcited"
            
            # Get current user (should be root)
            REMOTE_USER="$(id -un)"
            REMOTE_GROUP="$(id -gn)"
            
            echo "== Remote identity =="
            whoami
            id
            
            # Verify xcited user exists (should exist since domain exists)
            if ! id -u "${OWNER_USER}" >/dev/null 2>&1; then
              echo "‚ö†Ô∏è  ERROR: user '${OWNER_USER}' does not exist!"
              echo "   User should exist since domain xcited.ro exists in CWP7pro"
              echo "   Please verify user exists or create it manually"
              exit 1
            fi
            if ! getent group "${OWNER_GROUP}" >/dev/null 2>&1; then
              echo "‚ö†Ô∏è  WARN: group '${OWNER_GROUP}' does not exist. Creating group..."
              groupadd "${OWNER_GROUP}" 2>/dev/null || {
                echo "   Group creation failed, using existing group for user"
                OWNER_GROUP=$(id -gn "${OWNER_USER}")
              }
            fi
            
            echo "== Ensure target directory exists =="
            mkdir -p "${TARGET}"
            
            echo "== Set correct ownership and permissions (POST-SCP) =="
            # CRITICAL: SCP may copy files as root, so we MUST fix ownership after SCP
            # Use sudo -n (non-interactive) to ensure it works even if we're already root
            echo "üîß Setting ownership to ${OWNER_USER}:${OWNER_GROUP}..."
            
            # Use sudo -n (non-interactive) like 1dream does
            if sudo -n true 2>/dev/null; then
              echo "   Using sudo -n (non-interactive)..."
              sudo -n chown -R "${OWNER_USER}:${OWNER_GROUP}" "${TARGET}" || {
                echo "‚ö†Ô∏è  sudo -n chown failed, trying without -n..."
                sudo chown -R "${OWNER_USER}:${OWNER_GROUP}" "${TARGET}" || {
                  echo "‚ùå Ownership change failed"
                  exit 1
                }
              }
            else
              # If we're already root, chown should work directly
              chown -R "${OWNER_USER}:${OWNER_GROUP}" "${TARGET}" || {
                echo "‚ùå Ownership change failed (not root and no sudo)"
                exit 1
              }
            fi
            
            # Verify ownership was set correctly
            echo "üîç Verifying ownership..."
            WRONG_OWNER=$(find "${TARGET}" ! -user "${OWNER_USER}" -o ! -group "${OWNER_GROUP}" 2>/dev/null | head -10)
            if [ -n "$WRONG_OWNER" ]; then
              echo "‚ö†Ô∏è  WARNING: Some files still have wrong ownership:"
              echo "$WRONG_OWNER"
              echo "   Attempting aggressive fix..."
              if sudo -n true 2>/dev/null; then
                sudo -n find "${TARGET}" ! -user "${OWNER_USER}" -exec chown "${OWNER_USER}:${OWNER_GROUP}" {} \; 2>/dev/null || true
                sudo -n find "${TARGET}" ! -group "${OWNER_GROUP}" -exec chgrp "${OWNER_GROUP}" {} \; 2>/dev/null || true
              fi
            else
              echo "‚úÖ All files have correct ownership: ${OWNER_USER}:${OWNER_GROUP}"
            fi
            
            # Set correct permissions for directories and files (like 1dream)
            # CRITICAL: Apache needs 755 for directories and 644 for files
            echo "üîß Setting permissions for Apache access..."
            if sudo -n true 2>/dev/null; then
              echo "   Using sudo to set permissions..."
              sudo -n chown -R "${OWNER_USER}:${OWNER_GROUP}" "${TARGET}" || true
              sudo -n find "${TARGET}" -type d -exec chmod 755 {} \; || true
              sudo -n find "${TARGET}" -type f -exec chmod 644 {} \; || true
              sudo -n chmod -R u+rwX "${TARGET}" || true
              # Ensure server.js is executable
              if [ -f "${TARGET}/deploy-package/server.js" ]; then
                sudo -n chmod +x "${TARGET}/deploy-package/server.js" || true
              fi
            else
              echo "   Setting permissions without sudo..."
              chown -R "${OWNER_USER}:${OWNER_GROUP}" "${TARGET}" 2>/dev/null || true
              find "${TARGET}" -type d -exec chmod 755 {} \; || true
              find "${TARGET}" -type f -exec chmod 644 {} \; || true
              chmod -R u+rwX "${TARGET}" || true
              # Ensure server.js is executable
              if [ -f "${TARGET}/deploy-package/server.js" ]; then
                chmod +x "${TARGET}/deploy-package/server.js" || true
              fi
            fi
            
            # Verify permissions are correct
            echo "üîç Verifying permissions..."
            if [ -d "${TARGET}/deploy-package" ]; then
              DIR_PERMS=$(stat -c '%a' "${TARGET}/deploy-package" 2>/dev/null || echo "unknown")
              echo "   deploy-package directory permissions: $DIR_PERMS (should be 755)"
              if [ "$DIR_PERMS" != "755" ] && [ "$DIR_PERMS" != "unknown" ]; then
                echo "   ‚ö†Ô∏è  WARN: Directory permissions are not 755, fixing..."
                chmod 755 "${TARGET}/deploy-package" || sudo -n chmod 755 "${TARGET}/deploy-package" || true
              fi
            fi
            
            # Final verification
            echo "üîç Final ownership verification..."
            ls -ld "${TARGET}"
            ls -la "${TARGET}" | head -10
            echo "   Owner: $(stat -c '%U:%G' "${TARGET}" 2>/dev/null || echo 'unknown')"
            echo "   Permissions: $(stat -c '%a' "${TARGET}" 2>/dev/null || echo 'unknown')"
            
            echo "‚úÖ Permissions set correctly"
            echo "   Owner: ${OWNER_USER}:${OWNER_GROUP}"
            echo "   Target: ${TARGET}"
            
      - name: Post-deploy - Setup Node.js and PM2
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.CWP_HOST }}
          username: ${{ secrets.CWP_USER }}
          password: ${{ secrets.CWP_SSH_KEY }}
          port: ${{ secrets.CWP_PORT || 22 }}
          script: |
            set -e
            TARGET="/home/xcited/public_html"
            OWNER_USER="xcited"
            OWNER_GROUP="xcited"
            cd "${TARGET}"
            
            # CRITICAL: Ensure Node.js 18+ is available (Next.js 16 requires Node 18+)
            echo "üîç Checking Node.js version..."
            if ! command -v node >/dev/null 2>&1; then
              echo "‚ö†Ô∏è  Node.js not found. Installing Node.js 20..."
              curl -fsSL https://rpm.nodesource.com/setup_20.x | bash - || echo "‚ö†Ô∏è  Node.js setup failed"
              yum install -y nodejs || echo "‚ö†Ô∏è  Node.js install failed"
            else
              NODE_VERSION=$(node -v 2>/dev/null || echo "v0.0.0")
              NODE_MAJOR=$(echo "$NODE_VERSION" | cut -d'v' -f2 | cut -d'.' -f1)
              echo "   Current Node.js version: $NODE_VERSION (major: $NODE_MAJOR)"
              
              if [ "$NODE_MAJOR" -lt 18 ]; then
                echo "‚ö†Ô∏è  Node.js version $NODE_VERSION is too old (Next.js 16 requires Node 18+)"
                echo "   Installing Node.js 20..."
                curl -fsSL https://rpm.nodesource.com/setup_20.x | bash - || echo "‚ö†Ô∏è  Node.js setup failed"
                yum install -y nodejs || echo "‚ö†Ô∏è  Node.js install failed"
                echo "   New Node.js version: $(node -v 2>/dev/null || echo 'unknown')"
              else
                echo "‚úÖ Node.js version is compatible: $NODE_VERSION"
              fi
            fi
            
            # Verify Node.js is accessible and get full path
            NODE_PATH=$(which node 2>/dev/null || echo "")
            if [ -z "$NODE_PATH" ]; then
              echo "‚ùå ERROR: Node.js not found in PATH"
              echo "   This will cause PM2 to fail"
              exit 1
            fi
            
            NODE_VERSION=$(node -v 2>/dev/null || echo "unknown")
            echo "   Node.js path: $NODE_PATH"
            echo "   Node.js version: $NODE_VERSION"
            
            # CRITICAL: If nvm is being used, we need to ensure PM2 uses the correct Node.js
            # Check if nvm is active and if so, use the system Node.js instead
            if echo "$NODE_PATH" | grep -q "nvm"; then
              echo "‚ö†Ô∏è  WARN: nvm is active, Node.js path: $NODE_PATH"
              echo "   This may cause PM2 to use wrong Node.js version"
              echo "   Checking for system Node.js..."
              
              # Try to find system Node.js (usually in /usr/bin/node or /usr/local/bin/node)
              SYSTEM_NODE=""
              for path in /usr/bin/node /usr/local/bin/node /opt/nodejs/bin/node; do
                if [ -f "$path" ]; then
                  SYS_VERSION=$($path -v 2>/dev/null || echo "")
                  if [ -n "$SYS_VERSION" ]; then
                    SYS_MAJOR=$(echo "$SYS_VERSION" | cut -d'v' -f2 | cut -d'.' -f1)
                    if [ "$SYS_MAJOR" -ge 18 ]; then
                      SYSTEM_NODE="$path"
                      echo "   ‚úÖ Found system Node.js $SYS_VERSION at: $SYSTEM_NODE"
                      NODE_PATH="$SYSTEM_NODE"
                      break
                    fi
                  fi
                fi
              done
              
              # If no system Node.js found, install it
              if [ -z "$SYSTEM_NODE" ]; then
                echo "   Installing Node.js 20 system-wide..."
                curl -fsSL https://rpm.nodesource.com/setup_20.x | bash - || echo "‚ö†Ô∏è  Node.js setup failed"
                yum install -y nodejs || echo "‚ö†Ô∏è  Node.js install failed"
                NODE_PATH=$(which node 2>/dev/null || echo "/usr/bin/node")
                echo "   New Node.js path: $NODE_PATH"
                echo "   New Node.js version: $(node -v 2>/dev/null || echo 'unknown')"
              fi
            fi
            
            # Final verification
            FINAL_VERSION=$($NODE_PATH -v 2>/dev/null || echo "unknown")
            FINAL_MAJOR=$(echo "$FINAL_VERSION" | cut -d'v' -f2 | cut -d'.' -f1)
            if [ "$FINAL_MAJOR" -lt 18 ]; then
              echo "‚ùå ERROR: Node.js version $FINAL_VERSION is still too old (requires 18+)"
              echo "   Path: $NODE_PATH"
              exit 1
            fi
            
            echo "‚úÖ Using Node.js $FINAL_VERSION from: $NODE_PATH"
            
            # Install dependencies (for standalone build, minimal install needed)
            if [ -f "package.json" ]; then
              npm install --production || npm ci --production --frozen-lockfile || echo "‚ö†Ô∏è  npm install failed (continuing...)"
            fi
            
            # Prisma setup
            if [ -d "prisma" ]; then
              npx prisma generate || echo "‚ö†Ô∏è  Prisma generate failed (continuing...)"
              if [ -n "${{ secrets.DATABASE_URL }}" ] && [ "${{ secrets.DATABASE_URL }}" != "postgresql://user:pass@localhost:5432/xcited" ]; then
                DATABASE_URL="${{ secrets.DATABASE_URL }}" npx prisma migrate deploy || echo "‚ö†Ô∏è  Migrations failed (continuing...)"
              fi
            fi
            
            # CRITICAL: Ensure PM2 uses Node.js 20
            echo "üîç Checking PM2 Node.js version..."
            PM2_NODE=$(pm2 describe pm2 2>/dev/null | grep "interpreter" | head -1 | awk '{print $2}' || echo "")
            if [ -z "$PM2_NODE" ]; then
              PM2_NODE=$(which node 2>/dev/null || echo "")
            fi
            
            echo "   PM2 is using Node.js: $PM2_NODE"
            if [ -n "$PM2_NODE" ]; then
              PM2_NODE_VER=$($PM2_NODE -v 2>/dev/null || echo "unknown")
              PM2_NODE_MAJOR=$(echo "$PM2_NODE_VER" | cut -d'v' -f2 | cut -d'.' -f1)
              echo "   PM2 Node.js version: $PM2_NODE_VER (major: $PM2_NODE_MAJOR)"
              
              if [ "$PM2_NODE_MAJOR" -lt 18 ] || echo "$PM2_NODE" | grep -q "nvm"; then
                echo "‚ö†Ô∏è  CRITICAL: PM2 is using Node.js v14 from nvm"
                echo "   Reinstalling PM2 with system Node.js 20..."
                
                # Find or install system Node.js 20
                SYSTEM_NODE=""
                for path in /usr/bin/node /usr/local/bin/node /opt/nodejs/bin/node; do
                  if [ -f "$path" ]; then
                    VER=$($path -v 2>/dev/null || echo "")
                    if [ -n "$VER" ]; then
                      MAJOR=$(echo "$VER" | cut -d'v' -f2 | cut -d'.' -f1)
                      if [ "$MAJOR" -ge 18 ]; then
                        SYSTEM_NODE="$path"
                        echo "   ‚úÖ Found system Node.js $VER at: $SYSTEM_NODE"
                        break
                      fi
                    fi
                  fi
                done
                
                if [ -z "$SYSTEM_NODE" ]; then
                  echo "   Installing Node.js 20 system-wide..."
                  curl -fsSL https://rpm.nodesource.com/setup_20.x | bash - || echo "‚ö†Ô∏è  Node.js setup failed"
                  yum install -y nodejs || echo "‚ö†Ô∏è  Node.js install failed"
                  SYSTEM_NODE="/usr/bin/node"
                fi
                
                # Reinstall PM2 with system Node.js 20
                echo "   Reinstalling PM2 with $SYSTEM_NODE..."
                export PATH="/usr/bin:/usr/local/bin:/opt/nodejs/bin:$PATH"
                $SYSTEM_NODE -v
                npm uninstall -g pm2 2>/dev/null || true
                $SYSTEM_NODE $(which npm 2>/dev/null || echo "/usr/bin/npm") install -g pm2 || {
                  echo "   ‚ö†Ô∏è  PM2 reinstall failed, trying alternative..."
                  /usr/bin/npm install -g pm2 || echo "   ‚ö†Ô∏è  Alternative PM2 install also failed"
                }
                
                # Verify PM2 now uses correct Node.js
                NEW_PM2_NODE=$(which pm2 2>/dev/null || echo "")
                if [ -n "$NEW_PM2_NODE" ]; then
                  echo "   ‚úÖ PM2 reinstalled at: $NEW_PM2_NODE"
                fi
              else
                echo "   ‚úÖ PM2 is using correct Node.js version"
              fi
            fi
            
            # PM2 management
            echo "üîÑ Managing PM2 process..."
            pm2 delete xcited-web 2>/dev/null || true
            
            # CRITICAL: Kill any process using port 3002 (like wishhub does)
            echo "üîç Checking for processes using port 3002..."
            PORT_3002_PID=$(ss -ltnp 2>/dev/null | grep ':3002' | grep -oP 'pid=\K[0-9]+' | head -1 || echo "")
            if [ -n "$PORT_3002_PID" ]; then
              echo "   ‚ö†Ô∏è  Found process $PORT_3002_PID using port 3002"
              echo "   Killing process $PORT_3002_PID..."
              kill -9 "$PORT_3002_PID" 2>/dev/null || true
              sleep 2
              # Verify port is free
              if ss -ltnp 2>/dev/null | grep -q ':3002'; then
                echo "   ‚ö†Ô∏è  Port 3002 still in use, trying harder..."
                pkill -9 -f "next-server.*3002" 2>/dev/null || true
                pkill -9 -f "server.js.*3002" 2>/dev/null || true
                sleep 2
              fi
            fi
            
            # Verify port 3002 is free
            if ss -ltnp 2>/dev/null | grep -q ':3002'; then
              echo "   ‚ö†Ô∏è  WARN: Port 3002 is still in use after cleanup"
              ss -ltnp 2>/dev/null | grep ':3002' || true
            else
              echo "   ‚úÖ Port 3002 is free"
            fi
            
            # Set PATH to prioritize system Node.js
            export PATH="/usr/bin:/usr/local/bin:/opt/nodejs/bin:$PATH"
            echo "   Using PATH: $PATH"
            echo "   Node.js: $(which node) ($(node -v 2>/dev/null || echo 'unknown'))"
            
            # Find server.js in standalone build structure (exclude node_modules)
            echo "üîç Searching for server.js and .next directory..."
            echo "üìÅ Current directory structure:"
            ls -la | head -20
            echo ""
            
            SERVER_JS=""
            if [ -f "server.js" ]; then
              SERVER_JS="server.js"
              echo "   ‚úÖ Found server.js in root"
            elif [ -f ".next/standalone/server.js" ]; then
              SERVER_JS=".next/standalone/server.js"
              echo "   ‚úÖ Found server.js in .next/standalone/"
            elif [ -f "standalone/server.js" ]; then
              SERVER_JS="standalone/server.js"
              echo "   ‚úÖ Found server.js in standalone/"
            else
              echo "   üîç Searching for server.js (excluding node_modules)..."
              SERVER_JS=$(find . -name "server.js" -type f -not -path "*/node_modules/*" | head -1)
              if [ -n "$SERVER_JS" ]; then
                echo "   ‚úÖ Found server.js at: $SERVER_JS"
              fi
            fi
            
            if [ -z "$SERVER_JS" ] || [ ! -f "$SERVER_JS" ]; then
              echo "‚ùå ERROR: server.js not found"
              echo "üìÅ Current directory structure:"
              ls -la
              echo ""
              echo "üîç Searching for server.js (excluding node_modules)..."
              find . -name "server.js" -type f -not -path "*/node_modules/*" || echo "No server.js found"
              echo ""
              echo "‚ùå Cannot start PM2 without server.js"
              exit 1
            fi
            
            echo "‚úÖ Found server.js at: $SERVER_JS"
            
            # CRITICAL: Verify .next directory exists relative to server.js
            SERVER_DIR=$(dirname "$SERVER_JS")
            if [ "$SERVER_DIR" = "." ]; then
              SERVER_DIR=$(pwd)
            else
              SERVER_DIR=$(cd "$SERVER_DIR" && pwd)
            fi
            
            echo "   Server.js directory: $SERVER_DIR"
            
            # Check for .next in various locations
            NEXT_DIR=""
            if [ -d "$SERVER_DIR/.next" ]; then
              NEXT_DIR="$SERVER_DIR/.next"
              echo "   ‚úÖ Found .next in server.js directory"
            elif [ -d ".next" ]; then
              NEXT_DIR=".next"
              echo "   ‚úÖ Found .next in current directory"
            elif [ -d "$(pwd)/.next" ]; then
              NEXT_DIR="$(pwd)/.next"
              echo "   ‚úÖ Found .next in working directory"
            else
              echo "   ‚ö†Ô∏è  WARN: .next directory not found near server.js"
              echo "   Searching for .next directory..."
              find . -type d -name ".next" -not -path "*/node_modules/*" | head -5
            fi
            
            if [ -z "$NEXT_DIR" ] || [ ! -d "$NEXT_DIR" ]; then
              echo "‚ùå ERROR: .next directory not found!"
              echo "   This will cause: 'Could not find a production build in the ./.next directory'"
              echo "   Current directory: $(pwd)"
              echo "   Server.js: $SERVER_JS"
              echo "   Listing all .next directories:"
              find . -type d -name ".next" -not -path "*/node_modules/*" || echo "   No .next directories found"
              exit 1
            fi
            
            echo "   ‚úÖ .next directory found: $NEXT_DIR"
            echo "   .next contents:"
            ls -la "$NEXT_DIR" | head -10 || echo "   Cannot list .next directory"
            
            # CRITICAL: PM2 must use system Node.js 20, not nvm Node.js 14
            echo "üîç Verifying PM2 uses correct Node.js..."
            PM2_NODE_PATH=$(which pm2 2>/dev/null || echo "")
            if [ -n "$PM2_NODE_PATH" ]; then
              echo "   PM2 path: $PM2_NODE_PATH"
              # Check what Node.js PM2 uses
              PM2_NODE=$(head -1 "$PM2_NODE_PATH" 2>/dev/null | grep -oP 'node.*' || echo "")
              echo "   PM2 shebang: $PM2_NODE"
            fi
            
            # Set PATH to prioritize system Node.js (BEFORE any PM2 commands)
            export PATH="/usr/bin:/usr/local/bin:/opt/nodejs/bin:$PATH"
            export NODE_ENV="production"
            export PORT="3002"
            
            # Verify we're using system Node.js
            SYSTEM_NODE=$(which node 2>/dev/null || echo "")
            SYSTEM_NODE_VER=$(node -v 2>/dev/null || echo "unknown")
            SYSTEM_NODE_MAJOR=$(echo "$SYSTEM_NODE_VER" | cut -d'v' -f2 | cut -d'.' -f1)
            
            echo "   Current Node.js: $SYSTEM_NODE ($SYSTEM_NODE_VER, major: $SYSTEM_NODE_MAJOR)"
            
            if [ "$SYSTEM_NODE_MAJOR" -lt 18 ] || echo "$SYSTEM_NODE" | grep -q "nvm"; then
              echo "‚ùå ERROR: Still using old Node.js or nvm"
              echo "   Node.js path: $SYSTEM_NODE"
              echo "   This will cause the same error"
              exit 1
            fi
            
            echo "‚úÖ Using system Node.js $SYSTEM_NODE_VER"
            echo "   Script: $SERVER_JS"
            echo "   Working directory: $(pwd)"
            
            # Verify server.js exists and is executable
            if [ ! -f "$SERVER_JS" ]; then
              echo "‚ùå ERROR: server.js not found at: $SERVER_JS"
              exit 1
            fi
            
            echo "   Server.js exists: $SERVER_JS"
            echo "   Server.js permissions: $(ls -l "$SERVER_JS" | awk '{print $1, $3, $4}')"
            
            # CRITICAL: Delete old PM2 processes first (they may be using wrong Node.js)
            echo "üîÑ Stopping and deleting old PM2 processes..."
            pm2 delete xcited-web 2>/dev/null || true
            
            # Kill any process using port 3002
            echo "üîç Checking for processes using port 3002..."
            PORT_3002_PID=$(ss -ltnp 2>/dev/null | grep ':3002' | grep -oP 'pid=\K[0-9]+' | head -1 || echo "")
            if [ -n "$PORT_3002_PID" ]; then
              echo "   ‚ö†Ô∏è  Found process $PORT_3002_PID using port 3002"
              echo "   Killing process $PORT_3002_PID..."
              kill -9 "$PORT_3002_PID" 2>/dev/null || true
              pkill -9 -f "next-server.*3002" 2>/dev/null || true
              pkill -9 -f "server.js.*3002" 2>/dev/null || true
              sleep 2
            fi
            
            # Verify port 3002 is free
            if ss -ltnp 2>/dev/null | grep -q ':3002'; then
              echo "   ‚ö†Ô∏è  WARN: Port 3002 is still in use"
              ss -ltnp 2>/dev/null | grep ':3002' || true
            else
              echo "   ‚úÖ Port 3002 is free"
            fi
            
            pm2 kill 2>/dev/null || true
            sleep 2
            
            # Start PM2 directly like wishhub (no ecosystem.config.js needed)
            echo "üìã Starting PM2 with system Node.js..."
            echo "   Command: pm2 start \"$SERVER_JS\" --name xcited-web --update-env"
            pm2 start "$SERVER_JS" --name xcited-web --update-env
            
            # Wait for process to initialize
            echo "‚è≥ Waiting for process to start..."
            sleep 5
            
            # Check PM2 status immediately
            echo "üìä PM2 Status:"
            pm2 list
            
            # Get detailed process info
            echo "üìã PM2 Process Details:"
            pm2 describe xcited-web 2>&1 || echo "   ‚ö†Ô∏è  Process not found"
            
            # Check process status
            PM2_STATUS=$(pm2 jlist 2>/dev/null | grep -A 10 '"name":"xcited-web"' | grep '"status"' | head -1 | cut -d'"' -f4 || echo "unknown")
            PM2_RESTARTS=$(pm2 jlist 2>/dev/null | grep -A 10 '"name":"xcited-web"' | grep '"restart_time"' | head -1 | cut -d':' -f2 | tr -d ' ,' || echo "0")
            
            echo "   Process status: $PM2_STATUS"
            echo "   Restart count: $PM2_RESTARTS"
            
            if [ "$PM2_STATUS" != "online" ]; then
              echo "   ‚ö†Ô∏è  Process is not online!"
              echo "   Checking error logs..."
              pm2 logs xcited-web --lines 50 --nostream --err 2>/dev/null || echo "   No error logs"
              echo ""
              echo "   Checking output logs..."
              pm2 logs xcited-web --lines 50 --nostream --out 2>/dev/null || echo "   No output logs"
            fi
            
            pm2 save
            echo "‚úÖ PM2 process management completed"
            
      - name: Post-deploy - Verify and configure Apache
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.CWP_HOST }}
          username: ${{ secrets.CWP_USER }}
          password: ${{ secrets.CWP_SSH_KEY }}
          port: ${{ secrets.CWP_PORT || 22 }}
          script: |
            set -e
            TARGET="/home/xcited/public_html"
            
            # Test if application responds on port 3002
            echo "üîç Testing application on port 3002..."
            sleep 2
            if curl -f -s http://localhost:3002 >/dev/null 2>&1; then
              echo "‚úÖ Application responds on port 3002"
              curl -I http://localhost:3002 2>/dev/null | head -5
            else
              echo "‚ùå Application does NOT respond on port 3002"
              echo "   Checking if port is listening:"
              ss -ltnp 2>/dev/null | grep ':3002' || echo "   Port 3002 is not listening"
              echo ""
              echo "   Checking PM2 logs for errors:"
              pm2 logs xcited-web --lines 50 --nostream --err 2>/dev/null || echo "   No error logs"
              echo ""
              echo "   Checking PM2 logs for output:"
              pm2 logs xcited-web --lines 50 --nostream --out 2>/dev/null || echo "   No output logs"
            fi
            
            # CRITICAL: Fix CWP7pro VirtualHost - ProxyPass MUST be before Directory
            echo "üåê Fixing CWP7pro VirtualHost for xcited.ro..."
            
            CWP_VHOST="/usr/local/apache/conf.d/vhosts/xcited.ro.conf"
            if [ ! -f "$CWP_VHOST" ]; then
              echo "   ‚ùå ERROR: CWP VirtualHost not found at $CWP_VHOST"
              exit 1
            fi
            
            echo "   Found CWP VirtualHost: $CWP_VHOST"
            
            # Backup
            BACKUP="${CWP_VHOST}.backup.$(date +%s)"
            cp "$CWP_VHOST" "$BACKUP"
            echo "   Backup created: $BACKUP"
            
            # Step 1: Update port from 2095 to 3002 (first occurrence only)
            if grep -q "ProxyPass / http://127.0.0.1:2095/" "$CWP_VHOST"; then
              echo "   Updating ProxyPass port from 2095 to 3002..."
              sed -i '0,/ProxyPass \/ http:\/\/127.0.0.1:2095\//s|2095|3002|g' "$CWP_VHOST"
              sed -i '0,/ProxyPassReverse \/ http:\/\/127.0.0.1:2095\//s|2095|3002|g' "$CWP_VHOST"
            fi
            
            # Step 2: CRITICAL - Move ProxyPass BEFORE Directory (fixes 403 Forbidden)
            echo "   Fixing ProxyPass order (must be before Directory)..."
            
            # Find first VirtualHost boundaries
            FIRST_VHOST_START=$(grep -n "^<VirtualHost" "$CWP_VHOST" | head -1 | cut -d: -f1)
            FIRST_VHOST_END=$(awk -v start="$FIRST_VHOST_START" 'NR > start && /^<\/VirtualHost>/ {print NR; exit}' "$CWP_VHOST")
            
            if [ -z "$FIRST_VHOST_START" ] || [ -z "$FIRST_VHOST_END" ]; then
              echo "   ‚ùå Could not find VirtualHost boundaries"
              exit 1
            fi
            
            # Extract first VirtualHost
            sed -n "${FIRST_VHOST_START},${FIRST_VHOST_END}p" "$CWP_VHOST" > /tmp/first_vhost.txt
            
            # Find relative line numbers in first VirtualHost
            DIR_LINE=$(grep -n "<Directory" /tmp/first_vhost.txt | head -1 | cut -d: -f1)
            PROXY_LINE=$(grep -n "ProxyPass /" /tmp/first_vhost.txt | head -1 | cut -d: -f1)
            
            if [ -n "$DIR_LINE" ] && [ -n "$PROXY_LINE" ] && [ "$DIR_LINE" -lt "$PROXY_LINE" ]; then
              echo "   ‚ö†Ô∏è  Directory ($DIR_LINE) is before ProxyPass ($PROXY_LINE) - FIXING..."
              
              # Find ProxyPass block boundaries (relative to first VirtualHost)
              PROXY_START=$(grep -n "ProxyPreserveHost\|ProxyPass" /tmp/first_vhost.txt | head -1 | cut -d: -f1)
              PROXY_END=$(grep -n "ProxyPassReverse\|ProxyRequests" /tmp/first_vhost.txt | tail -1 | cut -d: -f1)
              
              # Extract ProxyPass block
              sed -n "${PROXY_START},${PROXY_END}p" /tmp/first_vhost.txt > /tmp/proxy_block.txt
              
              # Build fixed VirtualHost: everything before Directory, then ProxyPass, then Directory and rest
              head -n $((DIR_LINE - 1)) /tmp/first_vhost.txt > /tmp/vhost_fixed.txt
              cat /tmp/proxy_block.txt >> /tmp/vhost_fixed.txt
              echo "" >> /tmp/vhost_fixed.txt
              # Directory and everything after, but remove old ProxyPass block
              sed -n "${DIR_LINE},${PROXY_END}p" /tmp/first_vhost.txt | grep -v "ProxyPreserveHost\|ProxyPass\|ProxyPassReverse\|ProxyRequests" > /tmp/temp_after_dir.txt
              tail -n +$((PROXY_END + 1)) /tmp/first_vhost.txt >> /tmp/temp_after_dir.txt
              cat /tmp/temp_after_dir.txt >> /tmp/vhost_fixed.txt
              
              # Replace first VirtualHost in original file
              head -n $((FIRST_VHOST_START - 1)) "$CWP_VHOST" > /tmp/vhost_new.txt
              cat /tmp/vhost_fixed.txt >> /tmp/vhost_new.txt
              tail -n +$((FIRST_VHOST_END + 1)) "$CWP_VHOST" >> /tmp/vhost_new.txt 2>/dev/null || true
              
              mv /tmp/vhost_new.txt "$CWP_VHOST"
              echo "   ‚úÖ ProxyPass moved before Directory"
            else
              echo "   ‚úÖ ProxyPass order is correct (ProxyPass at $PROXY_LINE, Directory at $DIR_LINE)"
            fi
            
            # Verify ProxyPass port is 3002
            if ! grep -q "ProxyPass / http://127.0.0.1:3002/" "$CWP_VHOST"; then
              echo "   ‚ö†Ô∏è  Updating ProxyPass port to 3002..."
              sed -i 's|ProxyPass / http://127.0.0.1:[0-9]*/|ProxyPass / http://127.0.0.1:3002/|g' "$CWP_VHOST"
              sed -i 's|ProxyPassReverse / http://127.0.0.1:[0-9]*/|ProxyPassReverse / http://127.0.0.1:3002/|g' "$CWP_VHOST"
            fi
            
            echo "   ‚úÖ VirtualHost configuration fixed"
            
            # Test Apache configuration
            # Find Apache/httpd command (CWP7pro may have it in different locations)
            HTTPD_CMD=""
            for cmd in "/usr/sbin/httpd" "/usr/local/apache/bin/httpd" "/usr/bin/httpd" "httpd" "/usr/sbin/apache2ctl" "/usr/bin/apache2ctl" "apache2ctl"; do
              if command -v "$cmd" >/dev/null 2>&1 || [ -f "$cmd" ]; then
                HTTPD_CMD="$cmd"
                break
              fi
            done
            
            if [ -n "$HTTPD_CMD" ]; then
              echo "   Found Apache command: $HTTPD_CMD"
              
              # Test configuration (may need sudo)
              if sudo -n "$HTTPD_CMD" -t 2>/dev/null || "$HTTPD_CMD" -t 2>/dev/null; then
                echo "   ‚úÖ Apache configuration is valid"
                
                # Reload Apache
                if sudo -n systemctl reload httpd 2>/dev/null || systemctl reload httpd 2>/dev/null; then
                  echo "   ‚úÖ Apache reloaded"
                elif sudo -n systemctl restart httpd 2>/dev/null || systemctl restart httpd 2>/dev/null; then
                  echo "   ‚úÖ Apache restarted"
                elif sudo -n systemctl reload apache2 2>/dev/null || systemctl reload apache2 2>/dev/null; then
                  echo "   ‚úÖ Apache reloaded"
                elif sudo -n systemctl restart apache2 2>/dev/null || systemctl restart apache2 2>/dev/null; then
                  echo "   ‚úÖ Apache restarted"
                elif sudo -n "$HTTPD_CMD" -k graceful 2>/dev/null || "$HTTPD_CMD" -k graceful 2>/dev/null; then
                  echo "   ‚úÖ Apache gracefully reloaded"
                else
                  echo "   ‚ö†Ô∏è  Apache reload/restart failed (may need manual restart)"
                  echo "   Try: $HTTPD_CMD -k graceful"
                fi
              else
                echo "   ‚ö†Ô∏è  Could not test Apache configuration (may need sudo)"
                echo "   Configuration file: $APACHE_CONFIG"
              fi
            else
              echo "   ‚ö†Ô∏è  Apache command not found, configuration file: $APACHE_CONFIG"
              echo "   Please test and restart Apache manually"
            fi
            
            # Final permissions check for Apache
            echo "üîç Final permissions check for Apache..."
            echo "   Target directory:"
            ls -ld "${TARGET}"
            echo "   Sample files:"
            ls -la "${TARGET}" | head -15
            echo "   Owner: $(stat -c '%U:%G' "${TARGET}" 2>/dev/null || echo 'unknown')"
            echo "   Permissions: $(stat -c '%a' "${TARGET}" 2>/dev/null || echo 'unknown')"
            
            # Check if Apache can access (if running as apache user)
            if id apache >/dev/null 2>&1; then
              echo "   Apache user exists, checking access..."
              # Apache should be able to read files with 644 and directories with 755
              if [ -r "${TARGET}" ]; then
                echo "   ‚úÖ Apache can read target directory"
              else
                echo "   ‚ö†Ô∏è  WARN: Apache may not be able to read target directory"
              fi
            fi
            
            # Check SELinux context (if applicable)
            if command -v getenforce >/dev/null 2>&1; then
              SELINUX_STATUS=$(getenforce 2>/dev/null || echo "Disabled")
              echo "   SELinux status: ${SELINUX_STATUS}"
              if [ "${SELINUX_STATUS}" != "Disabled" ]; then
                echo "   ‚ö†Ô∏è  WARN: SELinux is enabled - fixing context..."
                sudo -n chcon -R -t httpd_sys_content_t "${TARGET}" 2>/dev/null || sudo chcon -R -t httpd_sys_content_t "${TARGET}" 2>/dev/null || echo "   ‚ö†Ô∏è  SELinux context fix failed"
              fi
            fi
            
            # CRITICAL: Verify Apache can access the application on port 3002
            echo "üîç Verifying Apache can access application..."
            if curl -s -f http://127.0.0.1:3002 >/dev/null 2>&1; then
              echo "   ‚úÖ Application is accessible on localhost:3002"
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:3002 2>/dev/null || echo "000")
              echo "   HTTP response code: $HTTP_CODE"
            else
              echo "   ‚ùå ERROR: Application is NOT accessible on localhost:3002"
              echo "   This will cause 'Forbidden' errors in Apache"
              echo "   Checking if port 3002 is listening..."
              ss -ltnp 2>/dev/null | grep ':3002' || echo "   Port 3002 is not listening!"
              echo "   Checking PM2 status..."
              pm2 list | grep xcited-web || echo "   PM2 process not found!"
            fi
            
            # Check Apache error logs for clues
            echo "üîç Checking Apache error logs for 'Forbidden' errors..."
            # CWP7pro uses /usr/local/apache/logs/ instead of /var/log/httpd/
            APACHE_ERROR_LOG=""
            if [ -f "/usr/local/apache/logs/xcited_error.log" ]; then
              APACHE_ERROR_LOG="/usr/local/apache/logs/xcited_error.log"
            elif [ -f "/var/log/httpd/xcited_error.log" ]; then
              APACHE_ERROR_LOG="/var/log/httpd/xcited_error.log"
            elif [ -f "/usr/local/apache/logs/error_log" ]; then
              APACHE_ERROR_LOG="/usr/local/apache/logs/error_log"
            fi
            
            if [ -n "$APACHE_ERROR_LOG" ] && [ -f "$APACHE_ERROR_LOG" ]; then
              echo "   Last 10 lines of Apache error log ($APACHE_ERROR_LOG):"
              tail -10 "$APACHE_ERROR_LOG" 2>/dev/null || echo "   Cannot read error log"
            else
              echo "   Apache error log not found (checked multiple locations)"
            fi
            
            # Final PM2 status and logs
            echo ""
            echo "üîç Final PM2 Status:"
            pm2 list
            echo ""
            echo "üîç PM2 Process Info:"
            pm2 describe xcited-web 2>/dev/null || echo "   ‚ö†Ô∏è  Process not found"
            echo ""
            echo "üîç Last 30 lines of PM2 error log:"
            pm2 logs xcited-web --lines 30 --nostream --err 2>/dev/null || echo "   No error logs"
            echo ""
            echo "üîç Last 30 lines of PM2 output log:"
            pm2 logs xcited-web --lines 30 --nostream --out 2>/dev/null || echo "   No output logs"
            echo ""
            echo "üîç Testing application on port 3002:"
            if curl -f -s http://localhost:3002 >/dev/null 2>&1; then
              echo "   ‚úÖ Application responds on port 3002"
              curl -I http://localhost:3002 2>/dev/null | head -5
            else
              echo "   ‚ùå Application does NOT respond on port 3002"
              echo "   Checking if port is listening:"
              netstat -tulpn | grep 3002 || ss -tulpn | grep 3002 || echo "   Port 3002 is not listening"
            fi
            echo ""
            echo "üîç Apache error logs (last 20 lines):"
            if [ -f "/usr/local/apache/logs/xcited_error.log" ]; then
              tail -20 /usr/local/apache/logs/xcited_error.log 2>/dev/null || echo "   Cannot read error log"
            elif [ -f "/var/log/httpd/xcited_error.log" ]; then
              tail -20 /var/log/httpd/xcited_error.log 2>/dev/null || echo "   Cannot read error log"
            else
              echo "   No Apache error logs found"
            fi

